import streamlit as st
import pandas as pd
import requests
from io import BytesIO
import openpyxl

# Constants: URLs for ZIP code to state data on GitHub
ZIP_CODE_URL = "https://raw.githubusercontent.com/OpenDataDE/State-zip-code-GeoJSON/master/uszips.csv"

def load_zip_to_state_map():
    # Load ZIP code mapping from GitHub
    df = pd.read_csv(ZIP_CODE_URL, dtype={"zip": str})
    # Create dict zip -> state
    return dict(zip(df['zip'], df['state_name']))

def get_state_from_zip(zip_code, zip_to_state):
    return zip_to_state.get(zip_code.zfill(5), "Unknown")

def generate_state_summary(census_df, zip_to_state):
    # Clean and format census data similar to Format2CSA logic:
    # Replace codes with full text, format dates, clear specified columns

    # Date columns formatting example (if any column named 'DOB' or 'Date')
    # For this demo, assume 'DOB' is column E in original, here just if exists:
    for col in census_df.columns:
        if 'date' in col.lower():
            census_df[col] = pd.to_datetime(census_df[col], errors='coerce').dt.strftime('%m/%d/%Y')

    # Replace codes in a specific column, e.g. 'Relationship' in G (example)
    if 'Relationship' in census_df.columns:
        census_df['Relationship'] = census_df['Relationship'].replace({
            "E": "Employee", "EE": "Employee",
            "C": "Child", "CH": "Child",
            "S": "Spouse", "SP": "Spouse",
            "Domestic Partner": "Spouse"
        })

    # Enrollment Status replacement
    if 'Status' in census_df.columns:
        census_df['Status'] = census_df['Status'].replace({
            "Enrolled": "Enroll", "Waived": "Waive",
            "W": "Waive", "E": "Enroll"
        })

    # Map ZIP codes to states and count lives per state
    # Assuming ZIP code column 'Zip' or 'ZIP' or 'zip' (try to find)
    zip_col_candidates = ['Zip', 'ZIP', 'zip', 'ZipCode', 'zip_code', 'Zip Code']
    zip_col = None
    for col in zip_col_candidates:
        if col in census_df.columns:
            zip_col = col
            break
    if zip_col is None:
        st.error("No ZIP code column found in census data.")
        return None

    census_df['State'] = census_df[zip_col].astype(str).apply(lambda z: get_state_from_zip(z, zip_to_state))

    # Count lives per state
    state_counts = census_df['State'].value_counts().to_dict()

    # Assign service entity based on state logic
    def service_entity(state):
        if state in ["Wisconsin", "Minnesota", "Colorado", "Massachusetts"]:
            return "zizzl"
        elif state == "Florida":
            return "NHP"
        else:
            return "TWG"

    summary_rows = []
    for state, count in state_counts.items():
        summary_rows.append({
            "State": state,
            "Number of Lives": count,
            "Service Entity": service_entity(state)
        })

    summary_df = pd.DataFrame(summary_rows)

    return summary_df, census_df

def pipeline_update(state_summary_df, pipeline_path, new_or_match, prospect_name, match_name=None):
    # Load pipeline workbook & worksheet
    wb = openpyxl.load_workbook(pipeline_path)
    ws = wb["Pipeline Test"]

    # Find last row with data in column A
    last_row = ws.max_row

    # Determine target row for insert/update
    if new_or_match == "New":
        target_row = last_row + 1 if last_row >= 4 else 4
        name_to_write = prospect_name
    else:
        # Find row with match_name in col A
        target_row = None
        for row in ws.iter_rows(min_row=1, max_col=1, max_row=ws.max_row):
            cell = row[0]
            if cell.value == match_name:
                target_row = cell.row
                break
        if target_row is None:
            st.error("Prospect name to match not found in pipeline.")
            return False
        name_to_write = match_name

    ws.cell(row=target_row, column=1).value = name_to_write

    # Prepare state names string for column B
    state_names_str = ", ".join(state_summary_df['State'].tolist())

    ws.cell(row=target_row, column=2).value = state_names_str

    # Total lives sum for column H
    total_lives = state_summary_df["Number of Lives"].sum()
    ws.cell(row=target_row, column=8).value = total_lives

    # Service entity lives sums
    def sum_by_entity(entity):
        return state_summary_df.loc[state_summary_df["Service Entity"] == entity, "Number of Lives"].sum()

    ws.cell(row=target_row, column=13).value = sum_by_entity("zizzl")  # M
    ws.cell(row=target_row, column=14).value = sum_by_entity("TWG")    # N
    ws.cell(row=target_row, column=15).value = sum_by_entity("NHP")    # O

    # Save changes
    wb.save(pipeline_path)
    return True

# --- Streamlit UI ---

st.title("Census Data Formatting + State Summary + Pipeline Update Tool")

# Step 1: Load ZIP code map from GitHub
with st.spinner("Loading ZIP code to state mapping..."):
    zip_to_state_map = load_zip_to_state_map()

# Step 2: Upload census CSV file
uploaded_census = st.file_uploader("Upload Census CSV file", type=["csv"])
if uploaded_census:
    census_df = pd.read_csv(uploaded_census, dtype=str)

    # Generate state summary and format census
    with st.spinner("Processing census data..."):
        state_summary_df, formatted_census_df = generate_state_summary(census_df, zip_to_state_map)

    if state_summary_df is not None:
        st.subheader("State Summary")
        st.dataframe(state_summary_df)

        # Show some formatted census data preview
        st.subheader("Formatted Census Data Preview")
        st.dataframe(formatted_census_df.head(20))

        # Allow download of state summary Excel
        towrite = BytesIO()
        with pd.ExcelWriter(towrite, engine='openpyxl') as writer:
            state_summary_df.to_excel(writer, sheet_name="State Summary", index=False)
            formatted_census_df.to_excel(writer, sheet_name="Formatted Census", index=False)
        towrite.seek(0)
        st.download_button(label="Download Summary & Formatted Census Excel", data=towrite, file_name="StateSummary.xlsx", mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet")

        # Step 3: Pipeline update
        st.header("Pipeline Update")

        pipeline_file = st.file_uploader("Upload Pipeline Excel file (with 'Pipeline Test' sheet)", type=["xlsm", "xlsx"])
        if pipeline_file:
            # Save pipeline temporarily to disk for openpyxl
            pipeline_path = f"./temp_pipeline.xlsx"
            with open(pipeline_path, "wb") as f:
                f.write(pipeline_file.read())

            action = st.radio("Choose Prospect Action", options=["New", "Match"])
            if action == "New":
                new_name = st.text_input("Enter New Prospect Name")
                if new_name:
                    if st.button("Update Pipeline with New Prospect"):
                        success = pipeline_update(state_summary_df, pipeline_path, "New", new_name)
                        if success:
                            st.success("Pipeline updated with new prospect!")
                            with open(pipeline_path, "rb") as f:
                                st.download_button("Download Updated Pipeline Excel", f, file_name="Updated_Pipeline.xlsx")
            else:
                match_name = st.text_input("Enter Prospect Name to Match")
                if match_name:
                    if st.button("Update Pipeline with Matched Prospect"):
                        success = pipeline_update(state_summary_df, pipeline_path, "Match", None, match_name)
                        if success:
                            st.success("Pipeline updated with matched prospect!")
                            with open(pipeline_path, "rb") as f:
                                st.download_button("Download Updated Pipeline Excel", f, file_name="Updated_Pipeline.xlsx")
